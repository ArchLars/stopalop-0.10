# AGENTS.md

> Playbook for using OpenAI Codex to modernize StopAlop with minimal churn, safe guardrails, and reproducible outcomes on LFS

## 1) What this file is for

Codex reads and merges `AGENTS.md` files to guide how it works on your project. It looks in three places, then merges them from top to bottom: your global file at `~/.codex/AGENTS.md`, the repo-root `AGENTS.md` (this file), and an optional per-folder `AGENTS.md`. Keep this document in the repo root so every run of Codex inherits the same rules and context. ([GitHub][1])

> Note on terminology: the 2021 Codex model was deprecated, and today “Codex” refers to the open source terminal agent and related workflows on top of the OpenAI API. Use current GPT models through the Responses API with tool calling rather than the legacy Codex model. ([GitHub][2], [OpenAI Platform][3])

---

## 2) Project summary

**Goal** Modernize StopAlop, a 1993-era shell package manager, into a safe and maintainable tool for an LFS system, while preserving its minimalist sh character and reliance on core UNIX tools.

**Non goals** APT/pacman-class dependency solver, heavy language rewrites, pulling in non-POSIX dependencies by default.

**Target environment** LFS userspace and chroot installs, root on a disposable VM for destructive tests, GNU coreutils, `tar`, `cpio`, `find`, `sed`.

---

## 3) Operating rules for Codex on this repo

### 3.1 Hard constraints

* Stay POSIX sh, avoid Bash-isms unless the file explicitly uses `#!/usr/bin/env bash`.
* No new mandatory runtime dependencies beyond coreutils, tar, cpio, find, sed, gzip or xz.
* Do not change the on-disk package layout or `INSTALL/` control directory in Phase 0 and Phase 1.
* Prefer additive changes over rewrites. Touch as few lines as needed to achieve a safety or maintainability win.
* Never auto-run commands that modify the host without an explicit human approval. Use Codex’s approval prompts and sandboxing. On Linux Codex applies Landlock and seccomp for the sandbox. Keep it on by default. ([GitHub][1])

### 3.2 Allowed tools and APIs

* OpenAI Responses API with tool calling, Structured Outputs for JSON checklists and change plans. Recommended models: a generalist like GPT-4o for code edits, a reasoning model like o3 for planning and audits. ([OpenAI Platform][4])
* File Search as a retrieval tool when you attach local docs or historical logs to a run. ([OpenAI Platform][5])
* Function calling for plan generation, diff review, and CI glue tasks. ([OpenAI Platform][6])
* Code Interpreter is permitted only inside a sandbox and only for static analysis, hashing, or generating non-privileged fixtures. No network or package installs. ([OpenAI Platform][7])

### 3.3 Dev utilities Codex may introduce to CI, not to runtime

* **Linting** ShellCheck for sh issues, shfmt for consistent formatting. Only wire them in CI or `make lint`, do not require them at runtime. ([shellcheck.net][8], [GitHub][9])
* **Testing** bats-core for black-box tests around CLI behavior and file system effects. Again, CI and developer machines only. ([GitHub][10])

### 3.4 Privacy and safety defaults

* Prefer OpenAI Zero Data Retention when available. If your org requires ZDR, set Codex to avoid response storage. ([GitHub][1])
* Keep Codex sandbox enabled, ask-for-approval enabled, and operate in dry-run first when the task touches `/` or `$DESTDIR`.

---

## 4) Project context for the agent

* LFS does not prescribe a package manager, it documents approaches and caveats. StopAlop should align with LFS norms, especially around upgrade hazards and file tracking. ([linuxfromscratch.org][11])
* StopAlop’s character: tar and cpio based payloads, `INSTALL/` control files, simple hooks, no repo daemon. We keep this ethos and improve safety, integrity, and observability.

---

## 5) Phased roadmap (high level)

Each phase is designed so a single PR can land independently. Phases are ordered by safety payoff per line changed.

### Phase 0, minimal risk hardening (already scoped)

* Strict modes where POSIX allows, quote variables, safe `mktemp` and `trap`, set `umask` for temp and install steps, add a single-process lock, basic name sanitization.
* Archive hygiene, verify member names are not absolute and do not escape directories.
* Create a content manifest with SHA-256 per file during `create`, verify it during `install` before touching the root. Introduce a plain text package ledger under `/var/lib/stopalop`. Add dry-run and a minimal log file.
* Hooks run with reduced PATH and locale, reject world-writable or non-root owned hooks.

### Phase 1, integrity, conflicts, and rollback

* Promote the manifest to a first-class required control file, fail early on mismatch.
* Conflict detection using the ledger, require `--force` to clobber and print a clear report.
* One-level rollback store for files overwritten or removed during install or uninstall.

### Phase 2, CLI, UX, and repo indexing

* Consolidate `--root` behavior across commands, unify help and exit codes, add `--json` status output for automation.
* Add a tiny offline repo indexer that writes `index.txt` with name, version, arch, size, sha256, and an optional detached signature if `gpg` is present.

### Phase 3, compatibility and portability

* Feature probes for tar and cpio flags, numeric owner handling, normalize times for reproducibility.
* Architecture hints in filenames or `INSTALL/arch`, ignored if absent.

### Phase 4, testing and CI

* Add bats-core tests that run in a throwaway tmpfs or Docker volume. Include golden tests for create, install, verify, uninstall, rollback, and conflict detection.
* Wire ShellCheck and shfmt in CI. Lint fails block merges, format is advisory. ([GitHub][10], [shellcheck.net][8])

### Phase 5, documentation and operator playbooks

* Man page, README updates, operator cheat sheets for LFS workflows, failure recovery, and repo indexing.

### Phase 6, optional guardrails

* If `gpg` is present, verify package or index signatures. If absent, proceed with a warning to preserve LFS minimalism.

---

## 6) Agent roster and responsibilities

Use these roles as prompts or tasks, not separate codebases. Codex can switch roles based on the task description.

1. **Architect Agent**
   Produces change plans and acceptance criteria, never edits files. Output format should use Structured Outputs JSON so CI can parse the plan. Prefer o3 for this planning work. ([OpenAI Platform][12])

2. **Shell Refactor Agent**
   Applies minimal diffs to sh files, keeps POSIX semantics, preserves comments, and adds inline justification for any non-trivial change.

3. **Security Agent**
   Audits path handling, quoting, temp files, tar extraction, hook execution, and permission rules. Flags any shell globbing or word splitting hazards.

4. **Archivist Agent**
   Owns manifest format and verification logic. Ensures `sha256sum` usage is consistent and deterministic.

5. **Repo Index Agent**
   Generates and validates `index.txt`. If `gpg` exists, creates a detached signature. If not, writes a clear “unsigned” header.

6. **Test Engineer Agent**
   Adds or updates bats tests, fixtures, and sample packages. Ensures tests do not require network and work in a chroot.

7. **Docs Agent**
   Maintains man pages and README, updates examples after each behavioral change.

8. **Release Steward Agent**
   Cuts tags, updates changelog, summarizes breaking changes, and updates compatibility notes.

---

## 7) Workflows Codex should follow

### 7.1 Planning workflow

* Read this file and the script, then propose a change plan with: goal, scope, file list, exact edits, risks, test additions, and rollback steps, as JSON Structured Output. Use tool calling where helpful. ([OpenAI Platform][6])
* Ask for approval before any write. Use the built-in approval gate and keep sandbox on. ([GitHub][1])

### 7.2 Edit workflow

* Make the smallest possible change first. Prefer extracting a helper function rather than reordering large blocks.
* After edits, run ShellCheck and shfmt suggestions locally or in CI, do not auto-reformat entire files in one PR. ([shellcheck.net][8], [GitHub][9])

### 7.3 Test workflow

* For each behavior change, add a bats test that would fail before and pass after. Keep tests hermetic, use a temporary root and simulate package payloads. ([GitHub][10])

### 7.4 Verification workflow

* Generate a dry-run transcript and a real run transcript on a disposable root. Attach both to the PR as artifacts.

### 7.5 Release workflow

* Prepare a release notes draft that lists safety improvements, any new flags, and migration steps. Include a one-screen “Upgrade from previous StopAlop” section.

---

## 8) Prompts Codex should follow

Use these prompts in interactive runs or in CI with `codex exec`. Keep sandboxing enabled and approvals required. ([GitHub][1])

1. **Phase 0 audit prompt**
   “Read `stopalop` and propose a Phase 0 plan that adds strict modes, quoting, secure temp files, umask policy, and a single-process lock, without changing behavior. Output a JSON object named `plan` with sections: risks, exact edits by filename and line anchors, tests to add, and manual verification steps.”

2. **Manifest prompt**
   “Introduce a content manifest into `INSTALL/` at package create time, verify it at install time before any filesystem changes. Keep tar and cpio. Output a JSON change list and test plan.”

3. **Ledger and conflicts prompt**
   “Add a per-package file list under `/var/lib/stopalop`, detect file conflicts on install, require `--force` to proceed. Update uninstall logic to respect foreign files. Produce a minimal diff description.”

4. **Rollback prompt**
   “Before mutating files, back up changed paths under `/var/lib/stopalop/backups/<pkg>-<ts>`. Provide a simple restore action. Describe exactly where to hook into the existing code.”

5. **CI and tests prompt**
   “Add bats tests for create, install (verify manifest), conflict, uninstall, and rollback. Wire ShellCheck and shfmt into CI. Do not change runtime. Present a Makefile fragment and CI steps as a plan, not as code applied.”

---

## 9) Guardrails for risky operations

* Never execute shell snippets proposed by model output without human approval. Codex supports ask-for-approval and a sandbox that restricts system access, keep both enabled. ([GitHub][1])
* When a task touches `/etc`, `/usr`, or `/lib*`, require a dry-run first, then a real run on a temporary root or a container.
* If a step would remove a directory that contains files not owned by the package per the ledger, abort and print the list of foreign files.

---

## 10) Acceptance criteria per phase

**Phase 0**

* ShellCheck reports no errors of severity “error” on modified hunks.
* All new temp files use `mktemp` and are removed by `trap` on EXIT.
* Creating and installing a sample package in a tmp root produces identical results across two runs except timestamps.

**Phase 1**

* Installing a package with a modified file content fails before any live filesystem change occurs.
* Installing a package that overwrites a file owned by a different package fails without `--force` and prints a conflict report.

**Phase 2**

* `stopalop index` on a directory of packages produces a stable, sorted index with sha256 sums.
* `--root` works consistently across create, install, verify, uninstall.

**Phase 4**

* bats suite passes in a chroot without network.
* shfmt stable formatting on new lines, ShellCheck passes on changed hunks. ([GitHub][9], [shellcheck.net][8])

---

## 11) Model and API guidance for Codex

* Prefer GPT-4o for code changes and natural language grounding, use o3 when you need deeper planning or to resolve tricky POSIX edge cases. ([OpenAI Platform][13])
* Use the Responses API with function calling to emit machine-readable plans and checklists that CI can validate. Use Structured Outputs when you need strict JSON schemas. ([OpenAI Platform][4])
* Use File Search when you attach logs, previous manifests, or design notes for retrieval-augmented runs. ([OpenAI Platform][5])

---

## 12) CI wiring notes

* Lint step runs ShellCheck, format step runs shfmt, test step runs bats-core. These tools are development dependencies and must not be required on target systems. ([shellcheck.net][8], [GitHub][9])
* Optional job: run an end-to-end create, index, install, verify, uninstall cycle in a container that mounts a tmpfs as root.

---

## 13) LFS-specific guidance for agents and reviewers

* Favor techniques documented by LFS for tracking and upgrades, do not introduce heavyweight solvers. This project aims at file tracking, clean uninstalls, and safe upgrades, not full dependency resolution. ([linuxfromscratch.org][11])
* Prefer `DESTDIR` style staging for tests and examples, even though StopAlop uses its own archive flow. This keeps destructive operations out of the live root during CI.

---

## 14) Documentation expectations

* Every behavioral change ships with updated `--help` text and a short changelog entry.
* The README must contain a “What changed” table that maps old commands to new flags or behaviors.

---

## 15) How to run Codex effectively on this repo

* Start in planning mode, ask Codex to output a JSON change plan and a test list. Approve only after you have read the plan and it fits the phase gates. Keep sandbox and approvals on. ([GitHub][1])
* When applying changes, limit each PR to one phase or sub-feature. Smaller reviews are safer.

---

## 16) Appendix, sources and references for agent features

* Codex CLI capabilities, AGENTS.md merging, sandbox and approvals, ZDR usage. ([GitHub][1])
* Responses API and migration notes. ([OpenAI Platform][4])
* Function calling and Assistants tool calling concepts. ([OpenAI Platform][6])
* Models overview, GPT-4o and o3 guidance. ([OpenAI Platform][13])
* File Search tool. ([OpenAI Platform][5])
* ShellCheck, shfmt, bats-core. ([shellcheck.net][8], [GitHub][9])
* LFS package management chapter. ([linuxfromscratch.org][11])

---

## 17) Definition of done for the whole effort

* StopAlop can create, install, verify, and uninstall packages with content hashing, a simple on-disk file ledger, conflict detection, and one-level rollback, while remaining POSIX sh and tar or cpio based.
* A reproducible test suite exists using bats-core, with lint and format checks in CI. No new runtime dependencies are required on the target system.
* Operators have a clear man page and README that explain safety guarantees, logs, and dry-run usage.

---

[1]: https://github.com/openai/codex "GitHub - openai/codex: Lightweight coding agent that runs in your terminal"
[2]: https://github.com/openai/codex?utm_source=chatgpt.com "openai/codex: Lightweight coding agent that runs in your ..."
[3]: https://platform.openai.com/docs/deprecations?utm_source=chatgpt.com "OpenAI deprecated GPT-3.5"
[4]: https://platform.openai.com/docs/guides/migrate-to-responses?utm_source=chatgpt.com "Migrating to Responses API"
[5]: https://platform.openai.com/docs/guides/tools-file-search?utm_source=chatgpt.com "File search - OpenAI API"
[6]: https://platform.openai.com/docs/guides/function-calling?utm_source=chatgpt.com "Function calling - OpenAI API"
[7]: https://platform.openai.com/docs/guides/tools-code-interpreter?utm_source=chatgpt.com "Code Interpreter - OpenAI API"
[8]: https://www.shellcheck.net/?utm_source=chatgpt.com "ShellCheck – shell script analysis tool"
[9]: https://github.com/mvdan/sh?utm_source=chatgpt.com "mvdan/sh: A shell parser, formatter, and interpreter with ..."
[10]: https://github.com/bats-core/bats-core?utm_source=chatgpt.com "bats-core/bats-core: Bash Automated Testing System"
[11]: https://www.linuxfromscratch.org/lfs/view/development/chapter08/pkgmgt.html?utm_source=chatgpt.com "8.2. Package Management"
[12]: https://platform.openai.com/docs/models/o3?utm_source=chatgpt.com "Model - OpenAI API"
[13]: https://platform.openai.com/docs/models/gpt-4o?utm_source=chatgpt.com "Model - OpenAI API"
